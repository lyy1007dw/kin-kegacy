---
name: backend-standards
description: |
  Enforces backend project structure, layering rules, naming conventions, and code quality standards
  for Java Spring Boot projects. Use when: writing backend code, reviewing code structure, creating
  new classes/packages, naming DTOs/entities/mappers, handling exceptions, writing logs, or when
  user mentions controller/service/mapper/entity/DTO or any Spring Boot backend development.
license: MIT
metadata:
  author: internal
  version: "1.0.0"
---

# Backend Project Global Standards

You are an expert Java Spring Boot backend developer who strictly enforces clean architecture,
layering boundaries, naming conventions, and code quality rules.

## When to Apply

Use this skill when:
- Creating or reviewing Controller / Service / Mapper / Entity / DTO classes
- Naming packages, classes, methods, or fields
- Structuring a new Spring Boot project
- Handling exceptions or writing logs
- Defining API response structures
- Validating request parameters
- Reviewing code for violations before commit

---

## Project Structure

```
src/main/java/{base-package}/
├── config/          # Global config (Beans, Security, Swagger)
├── constant/        # Constants and enums
├── controller/      # HTTP request/response only — no business logic
├── service/         # Business logic layer
│   └── impl/        # Service implementations
├── mapper/          # Data access layer — DB operations only
├── entity/          # DB entities — mirror table structure exactly
├── dto/             # Data Transfer Objects (request & response bodies)
├── vo/              # View Objects (optional, for display only)
├── converter/       # Object converters (Entity ↔ DTO / VO)
├── exception/       # Custom exceptions & global exception handler
├── util/            # Utility classes
└── interceptor/     # Interceptors / Filters
```

---

## Layer Responsibilities (Mandatory)

### Controller Layer
- ✅ Accept parameters, validate with annotations, call Service, return response
- ❌ No business logic
- ❌ No direct Mapper calls
- ❌ No direct Entity manipulation

```java
// ✅ Correct
@PostMapping("/user")
public Result<Void> createUser(@Valid @RequestBody UserCreateDTO dto) {
    userService.createUser(dto);
    return Result.success();
}

// ❌ Wrong: Controller calling Mapper directly
@PostMapping("/user")
public Result<Void> createUser(@RequestBody UserCreateDTO dto) {
    userMapper.insert(...); // FORBIDDEN!
    return Result.success();
}
```

### Service Layer
- ✅ Business logic orchestration, transaction control, Mapper calls
- ✅ Receives DTO, returns DTO or primitives; uses Entity internally
- ❌ No HTTP-related objects (HttpServletRequest etc.) unless absolutely necessary
- ❌ Never return Entity to Controller

### Mapper Layer
- ✅ DB operations only: CRUD, pagination, aggregation
- ✅ Parameters and return types: Entity, primitives, Map, custom result objects
- ❌ No business logic or conditional branching
- ❌ No DTO references (DTO must never appear in Mapper interface)
- ❌ No calls to other Mappers

```java
// ✅ Correct
List<User> selectByStatus(@Param("status") Integer status);

// ❌ Wrong: Mapper using DTO
List<User> selectByCondition(UserQueryDTO dto); // FORBIDDEN!
```

### Entity Layer
- ✅ Strictly mirrors DB table structure, field-to-column 1:1
- ❌ No non-DB fields (e.g. display-only fields)
- ❌ Never appear in Controller input/output params

### DTO Layer
- ✅ Data transfer between Controller ↔ Service
- ✅ JSR-303 validation annotations allowed (`@NotNull`, `@Size`, etc.)
- ❌ Never appear in Mapper layer

---

## Naming Conventions (Mandatory)

### Class Naming

| Type | Rule | Example |
|------|------|---------|
| Controller | `{Domain}Controller` | `UserController` |
| Service Interface | `{Domain}Service` | `UserService` |
| Service Impl | `{Domain}ServiceImpl` | `UserServiceImpl` |
| Mapper Interface | `{Domain}Mapper` | `UserMapper` |
| DB Entity | `{Domain}` / `{Domain}Entity` | `User` / `UserEntity` |
| DTO | `{Domain}{Scene}DTO` | `UserCreateDTO`, `UserQueryDTO`, `UserDetailDTO` |
| View Object | `{Domain}VO` | `UserVO` |
| Converter | `{Domain}Converter` | `UserConverter` |
| Exception | `{Domain}Exception` | `UserNotFoundException` |
| Constant | `{Domain}Constant` | `UserConstant` |
| Enum | `{Domain}Enum` | `UserStatusEnum` |
| Util | `{Function}Util` | `DateUtil`, `StringUtil` |

### DTO Naming Detail (Mandatory)

- Create request: `{Domain}CreateDTO`
- Update request: `{Domain}UpdateDTO`
- Query request: `{Domain}QueryDTO`
- Detail response: `{Domain}DetailDTO`
- List response: `{Domain}ListDTO`
- Paginated response: `PageResult<{Domain}ListDTO>`

> ⚠️ DTO suffix must be uppercase `DTO` — never abbreviate as `Dto`

### Method Naming

| Scenario | Prefix | Example |
|----------|--------|---------|
| Get single | `get` / `find` | `getUserById` |
| Get list | `list` / `find` | `listUsersByStatus` |
| Paginate | `page` | `pageUsers` |
| Create | `create` / `add` | `createUser` |
| Update | `update` | `updateUser` |
| Delete | `delete` / `remove` | `deleteUser` |
| Batch ops | `batch{Action}` | `batchDeleteUsers` |

---

## Package Naming (Mandatory)

- All lowercase, no camelCase
- Base package: `com.{company}.{project}`
- Strictly follow the directory structure — do not invent package names

```
✅ com.example.myproject.mapper
✅ com.example.myproject.dto
❌ com.example.myproject.dao        (use mapper)
❌ com.example.myproject.pojo       (use entity)
❌ com.example.myproject.model      (use entity or dto)
❌ com.example.myproject.request    (use dto)
❌ com.example.myproject.response   (use dto or vo)
```

---

## Field & Comment Standards

### Field Rules
- All fields use lowerCamelCase: `userName`, `createTime`
- Boolean DB fields prefix with `is`: `isDeleted`, `isEnabled`
- No single-letter variable names (except loop vars `i`, `j`, `k`)

### Comment Rules
- All Controller, Service interface, and DTO classes **must have class-level Javadoc**
- All public methods **must have method-level Javadoc**
- Complex business logic requires inline comments

```java
/**
 * User management controller
 *
 * @author yourname
 * @since 2024-01-01
 */
@RestController
@RequestMapping("/api/user")
public class UserController { ... }
```

---

## Unified Response Structure (Mandatory)

All APIs must use the unified response wrapper. Never return raw objects or Strings.

```java
public class Result<T> {
    private Integer code;    // 200 = success, others = failure
    private String message;  // Human-readable message
    private T data;          // Response payload
}

// ✅ Correct
public Result<UserDetailDTO> getUser(@PathVariable Long id) { ... }

// ❌ Wrong
public UserDetailDTO getUser(@PathVariable Long id) { ... }
public String getUser(@PathVariable Long id) { ... }
```

---

## Exception Handling

- Never use `e.printStackTrace()` — use Slf4j + Logback exclusively
- All business exceptions must extend `BusinessException` base class
- Global exception handling via `@RestControllerAdvice` — never silently catch exceptions in Service/Controller
- Always return HTTP 200; use the `code` field in the response body to signal business errors

---

## Other Constraints

### Prohibited Behaviors

| Behavior | Rule |
|----------|------|
| Magic numbers | All enum values and status codes must be defined as constants or enums |
| Hardcoded config | All environment config must live in `application.yml` |
| Cross-layer dependency | Controller must not depend directly on Mapper |
| Circular dependency | Services must not inject each other directly — decouple via interfaces |
| Large transactions | Minimize transaction scope; no HTTP calls or file I/O inside transactions |

### Logging Standards

```java
// ✅ Correct: use @Slf4j annotation
@Slf4j
public class UserService {
    log.info("Creating user, params: {}", dto);
    log.error("Failed to create user, userId: {}", userId, e);
}

// ❌ Wrong
System.out.println("User created");
e.printStackTrace();
```

### Validation Standards

- Input validation: JSR-303 annotations in DTO + `@Valid` on Controller method
- Service layer may do secondary business-rule validation, throwing `BusinessException`
- Never do null checks in Mapper layer

---

## Pre-Commit Checklist

Before submitting code, confirm all of the following:

- [ ] New class placed in the correct package
- [ ] DTO names end with uppercase `DTO`
- [ ] No business logic or DTO references in Mapper
- [ ] Controller does not call Mapper directly
- [ ] Entity does not appear in Controller input/output
- [ ] New APIs use unified `Result<T>` response wrapper
- [ ] No magic numbers or hardcoded config values
- [ ] All public methods have Javadoc comments
- [ ] Exceptions handled through global handler only
- [ ] Logging uses Slf4j — no `System.out` anywhere

---

## Example

**User Request:** "Create a user registration API."

**Response approach:**

1. Define `UserCreateDTO` with `@NotNull` / `@Email` validations
2. `UserController.createUser(@Valid @RequestBody UserCreateDTO dto)` calls `UserService`
3. `UserServiceImpl` validates business rules, converts DTO → `User` entity via `UserConverter`, calls `UserMapper.insert(user)`
4. Returns `Result.success()` — never returns Entity or raw object
5. Any business error throws `UserException extends BusinessException`, caught by `@RestControllerAdvice`
